import { TideProcessLogger } from '@gezhi/tide-process-common';
declare module '@gezhi/tide-process-script-sdk' {
  interface UserTaskInfo {
    artifactId: string;
    userTaskId: string;
    index?: string;
    args: any;
  }

  interface SetParticipantsForLane {
    $class?: string;
    laneId: string;
    type: 'id' | 'role';
    rules: string[];
    timestamp?: string;
  }
  
  interface QueryResponse {
    $class?: string;
    bookmark: string;
    queryResult: any[];
  }

  interface Artifact {
    $class?: string;   
    id: string;
    version?: string;
    metadata?: any;
    modelId: string;
    participants: any;
    modelType?: string;
  }
  interface FindOptions {
    bookmark?: string;
    limit?: number;
    /**
     * sort example: [{"name": "asc"}, {"age": "desc"}]
     */
    sort?: {[key: string]: 'acs'|'desc'}[];
    permitResourcesForRelationships?: boolean;
  }

  class ScriptSdk {
    constructor(...args: any[]);
    getLogger(name: string, level?: string): TideProcessLogger;
  
    /**
     * Returns the timestamp when the transaction was created.
     * This is taken from the transaction ChannelHeader, therefore
     * it will indicate the client's timestamp, and will have the
     * same value across all endorsers.
     *
     * @returns {Date} date when this tx was created
     */
    getTimestamp(): Date;
  
    getAssets(registryId: string): Promise<any[]>;
  
    getAsset(registryId: string, resourceId: string): Promise<any>;
  
    findAssets(registryId: string, condition: string, namedParams?: any, options?: FindOptions): Promise<QueryResponse>;
  
    resolveAsset(registryId: string, resourceId: string): Promise<any>;
  
    createAsset(registryId: string, resource: any, updateExisting?: boolean): Promise<void>;
  
    createAssets(registryId: string, resources: any[], updateExisting?: boolean): Promise<void>;
  
    updateAsset(registryId: string, resource: any): Promise<void>;
    
    updateAssets(registryId: string, resources: any[]): Promise<void>;
  
    removeAsset(registryId: string, resourceId: string): Promise<void>;
  
    removeAssets(registryId: string, resourceIds: string): Promise<void>;
  
    partialUpdate(registryId: string, resourceId: string, updatedFields: any): Promise<void>;
  
    createArtifact(artifact: Artifact): Promise<void>;
  
    signalUserTask(userTaskInfo: UserTaskInfo): Promise<any>;
  
    /**
     * Set participants for a lane
     *
     * @param {SetParticipantsForLane} tx
     */
    setParticipantsForLane(tx: SetParticipantsForLane);
  
    /**
     * Locally calls the specified chaincode <code>invoke()</code> using the
     * same transaction context; that is, chaincode calling chaincode doesn't
     * create a new transaction message.<br><br>
     *
     * If the called chaincode is on the same channel, it simply adds the called
     * chaincode read set and write set to the calling transaction.<br><br>
     * If the called chaincode is on a different channel,
     * only the Response is returned to the calling chaincode; any PutState calls
     * from the called chaincode will not have any effect on the ledger; that is,
     * the called chaincode on a different channel will not have its read set
     * and write set applied to the transaction. Only the calling chaincode's
     * read set and write set will be applied to the transaction. Effectively
     * the called chaincode on a different channel is a `Query`, which does not
     * participate in state validation checks in subsequent commit phase.<br><br>
     * If `channel` is empty, the caller's channel is assumed.
     * @async
     * @param {any} args List of arguments to pass to the called MSC
     * @returns {Promise.<string>}
     */
    invokeMSC(transaction: any): Promise<any>;
  }
}
